# ğŸ“˜ Handling HTTP Observables with RxJS in Angular

## ğŸ§  Objective

Learn how to:

* Fetch data using RxJS and Observables
* Filter the fetched data into categories (BEGINNER, ADVANCED)
* Avoid unnecessary HTTP calls using the `shareReplay()` operator

---

## ğŸ“¦ Setup

Before jumping into the examples, make sure you have this utility function set up to create HTTP observables:

```ts
// utils.ts
import { Observable, Observer } from "rxjs";

export function createHttpObservable(url: string) {
  return new Observable((observer: Observer<any>) => {
    fetch(url)
      .then((response) => response.json())
      .then((body) => {
        observer.next(body);
        observer.complete();
      })
      .catch((err) => observer.error(err));
  });
}
```

---

## ğŸ§ª Example 1: Basic `subscribe()` Pattern

```ts
beginnerCourses: CourseModel[];
advanceCourses: CourseModel[];

ngOnInit() {
  const http$ = createHttpObservable("/api/courses");

  const courses$: Observable<CourseModel[]> = http$.pipe(
    map((res) => Object.values(res["payload"]))
  );

  courses$.subscribe(
    (courses) => {
      this.beginnerCourses = courses.filter(course => course.category === "BEGINNER");
      this.advanceCourses = courses.filter(course => course.category === "ADVANCED");
    },
    noop,
    () => console.log("Completed")
  );
}
```

### âœ… Highlights

* Subscribes to the observable directly.
* Filters the data inside the `subscribe()` block.
* Simple and straightforward.

### âš ï¸ Caveats

* Direct subscription leads to **tight coupling** with component lifecycle.
* No reusability of filtered streams.

---

## ğŸ§ª Example 2: Using Derived Observables

```ts
beginnerCourses$: Observable<CourseModel[]>;
advanceCourses$: Observable<CourseModel[]>;

ngOnInit() {
  const http$ = createHttpObservable("/api/courses");

  const courses$: Observable<CourseModel[]> = http$.pipe(
    map((res) => Object.values(res["payload"]))
  );

  this.beginnerCourses$ = courses$.pipe(
    map(courses => courses.filter(course => course.category === "BEGINNER"))
  );

  this.advanceCourses$ = courses$.pipe(
    map(courses => courses.filter(course => course.category === "ADVANCED"))
  );
}
```

### âœ… Highlights

* Fully reactive and declarative approach.
* Clean separation of logic for each category.
* Ideal for `async` pipe usage in templates.

### âš ï¸ Caveats

* **Multiple subscriptions** to `courses$` causes **multiple HTTP requests** if not cached.

---

## ğŸ§ª Example 3: Avoiding Duplicate Requests with `shareReplay()`

```ts
const http$ = createHttpObservable("/api/courses");

const courses$: Observable<CourseModel[]> = http$.pipe(
  tap(() => console.log("HTTP request executed")),
  map((res) => Object.values(res["payload"])),
  shareReplay()
);

this.beginnerCourses$ = courses$.pipe(
  map(courses => courses.filter(course => course.category === "BEGINNER"))
);

this.advanceCourses$ = courses$.pipe(
  map(courses => courses.filter(course => course.category === "ADVANCED"))
);
```

### âœ… Highlights

* ğŸ§  **Smart caching**: `shareReplay()` ensures the HTTP request runs only **once**.
* ğŸ§¹ Clean reuse of `courses$` for multiple consumers.
* âœ… Perfect for performance optimization.

### ğŸ” Why `shareReplay()`?

* It **shares** the subscription among multiple observers.
* It **replays** the last emitted value to new subscribers.
* Especially useful when combining multiple derived streams from a single source.

---

## ğŸ” Summary Comparison

| Feature                    | Example 1                | Example 2                | Example 3 (`shareReplay`)    |
| -------------------------- | ------------------------ | ------------------------ | ---------------------------- |
| Approach                   | Direct subscription      | Derived observables      | Shared & replayed observable |
| Code Simplicity            | âœ… Simple                 | âœ… Modular                | âš  Slightly more advanced     |
| Multiple HTTP Calls        | âŒ Yes (per subscription) | âŒ Yes (per subscription) | âœ… No (shared request)        |
| Suitable for Async Pipe    | âŒ No                     | âœ… Yes                    | âœ… Yes                        |
| Reusability                | âŒ Low                    | âœ… High                   | âœ… High                       |
| Recommended for Production | âš  Not preferred          | âš  Use with caution       | âœ… Best practice              |

---

## âœ… Final Recommendation

For scalable and high-performance Angular apps:

> ğŸŸ¢ **Use `shareReplay()` when multiple parts of your app need the same data** from a single HTTP call.

Combine it with:

* `map()`, `filter()`, `tap()`
* `async` pipes in templates
* `catchError()` for robust error handling


