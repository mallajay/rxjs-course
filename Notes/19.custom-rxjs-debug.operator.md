A **custom RxJS operator** named `debug` to selectively log observable values to the console based on a **logging level system**. This is a clean and powerful way to control your debugging output in large-scale applications â€” especially when using a lot of observables.

---

# âœ… Custom `debug` Operator with Logging Levels

### âœ… Purpose:

- Helps **observe** and **debug** values flowing through RxJS observables.
- Only logs messages if the defined log level (e.g., `TRACE`, `INFO`) is **greater than or equal to** the **global RxJS logging level** set in your app.

---

## ğŸ”§ Custom Operator: `debug`

### ğŸ“Œ Usage Example:

```ts
course$ = createHttpObservable(`/api/courses/${this.courseId}`).pipe(debug(RxJsLoggingLevel.INFO, "course value"));
```

### ğŸ“Œ Operator Code:

```ts
export const debug = (level: number, message: string) => (source: Observable<any>) =>
  source.pipe(
    tap((val) => {
      if (level >= rxjsLoggingLevel) {
        console.log(message + ": ", val);
      }
    })
  );
```

### ğŸ“Œ Supporting Enum + Setter:

```ts
export enum RxJsLoggingLevel {
  TRACE,
  DEBUG,
  INFO,
  ERROR,
}

let rxjsLoggingLevel = RxJsLoggingLevel.INFO;

export function setRxjsLoggingLevel(level: RxJsLoggingLevel) {
  rxjsLoggingLevel = level;
}
```

---

## ğŸ§  How It Works

| Logging Level | Numeric Value | Example Usage                                  |
| ------------- | ------------- | ---------------------------------------------- |
| `TRACE`       | `0`           | Typing in input (detailed trace logs)          |
| `DEBUG`       | `1`           | Emitted values from operators like `switchMap` |
| `INFO`        | `2`           | HTTP response data                             |
| `ERROR`       | `3`           | Error handling                                 |

You call `setRxjsLoggingLevel()` once, and only messages at **that level or above** are printed:

```ts
setRxjsLoggingLevel(RxJsLoggingLevel.TRACE); // Most verbose
setRxjsLoggingLevel(RxJsLoggingLevel.INFO); // Production-suitable
```

---

## ğŸ“Š Real-Life Analogy

Think of logging levels as **filters** for what type of logs you're interested in:

- ğŸ `TRACE` = Log _everything_ â€” useful during deep debugging.
- ğŸ” `DEBUG` = Only useful runtime insights.
- â„¹ï¸ `INFO` = Major state changes like fetched data.
- â—`ERROR` = Only failures.

---

## ğŸ’¡ Benefits

âœ… Clean and consistent logging across the app
âœ… Avoids `console.log` spam
âœ… Makes debugging **scalable** and **configurable**
âœ… Can be easily **disabled** or turned down for production builds
âœ… Encourages separation of concerns â€” logs stay in operator pipes, not component logic

---

## ğŸ”„ Example with `switchMap`, `startWith`, `debug`

```ts
ngAfterViewInit() {
  this.lessons$ = fromEvent<any>(this.input.nativeElement, "keyup").pipe(
    map((event) => event.target.value),
    startWith(""),
    debug(RxJsLoggingLevel.TRACE, "Search Input"),
    debounceTime(400),
    distinctUntilChanged(),
    switchMap((search) => this.loadLessons(search)),
    debug(RxJsLoggingLevel.DEBUG, "Lessons Response")
  );
}
```

- **`TRACE`**: logs every keystroke before debounce.
- **`DEBUG`**: logs the result of `switchMap` after the HTTP request completes.

---

## âœ… Final Thoughts

This custom operator is a **best-practice approach** to observable debugging in Angular or any RxJS-powered app. Youâ€™ve made it:

- Modular âœ…
- Configurable âœ…
- Non-intrusive âœ…

If you'd like, I can generate a clean `.md` documentation file from this explanation with examples and benefits. Would you like that?
